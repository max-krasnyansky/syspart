#!/bin/sh
# Startup script for syspart
#
# chkconfig: 12345 90 99
# description: Partition system resources

# Source function library.
. /etc/rc.d/init.d/functions

# Get config.
[ -f /etc/sysconfig/syspart ] || exit 5
. /etc/sysconfig/syspart

SYSCTL="/sbin/sysctl -q -e -w"

# Init cpusets
cpusetdir=/sys/fs/cgroup/cpuset
if [ ! -d $cpusetdir -o ! -f $cpusetdir/cpuset.cpus ]; then
	echo $cpusetdir does not exist or cpuset fs is not mounted
	exit 1
fi
 
cd $cpusetdir

# **** The rest of the script assumes that current directory is 
# **** the root of the cpuset tree

# Compute masks based on the config
# All cpus in the system
ALL_CPUS_MASK=`cat cpuset.cpus | bitops --fmt=lX`

# Backwards compatibility
[ "$GPP_CPUS" = ""] && GPP_CPUS=$PAR0_CPUS
[ "$GPP_MEMS" = ""] && GPP_MEMS=$PAR0_MEMS

# GPP cpus and memory nodes
GPP_CPUS_MASK=`echo $GPP_CPUS | bitops --fmt=lX`
GPP_CPUS_LIST=$GPP_CPUS
GPP_MEMS_LIST=$GPP_MEMS

# ISP cpus and memory nodes
[ "$ISP_CPUS" = "" ] && ISP_CPUS_MASK=`echo $ALL_CPUS_MASK | bitops --andnot $GPP_CPUS_MASK`
[ "$ISP_MEMS" = "" ] && ISP_MEMS=$GPP_MEMS
ISP_EACH_CPU=`echo $ISP_CPUS_MASK | bitops --fmt=xE`
ISP_MEMS_LIST=$ISP_MEMS

# Move tasks into a cpuset
move_tasks()
{
	# Try to move all tasks.
	# Those that can't be moved (per-cpu kernel threads, etc) won't move
	# whether we want to or not, no need to be careful here.
	par=$1
	ls -d /proc/[0-9]* | while read i; do
		pid=${i##*/}
		echo $pid > $par/cgroup.procs 2>/dev/null
	done
}

# Create cpusets
create_partitions()
{
	# Do not start twice to avoid conflicts.
	# For example we do not want to bring CPUs on/offline 
	# if stopmachine is disabled on them.
	if [ -d gpp ]; then
		echo System partitioning is already setup
		return 1
	fi

	# Set default IRQ affinity to GPP cpus
	echo $GPP_CPUS_MASK > /proc/irq/default_smp_affinity

	# Set affinity for all active IRQs
	for i in /proc/irq/[0-9]*; do
		echo $GPP_CPUS_MASK > $i/smp_affinity 2>/dev/null
	done

	# Disable systemwide load balancing
	echo 0 > cpuset.sched_load_balance

	# Bring ISP cpus offline
	for i in $ISP_EACH_CPU; do
		echo 0 > /sys/devices/system/cpu/cpu$i/online
	done

	# Create gpp cpuset
	if [ ! -d gpp ]; then
		mkdir gpp
		echo $GPP_CPUS_LIST > gpp/cpuset.cpus
		echo $GPP_MEMS_LIST > gpp/cpuset.mems
		echo 0 > gpp/cpuset.sched_load_balance
	fi

	# Move tasks into GPP
	move_tasks gpp
	echo "Re-running move_tasks"
	move_tasks gpp

	# Bring ISP cpus online.
	# Put each CPU into a separate cpuset, otherwise they 
	# endup in the same root domain which causes rt scheduler
	# lock contention.
	for i in $ISP_EACH_CPU; do
		echo 1 > /sys/devices/system/cpu/cpu$i/online
		mkdir cpu$i
		echo $i > cpu$i/cpuset.cpus
		echo $ISP_MEMS_LIST > cpu$i/cpuset.mems
	done

	# Disable stopmachine (if supported)
	$SYSCTL "kernel.stopmachine_disabled=1"

	# Restrict pagedrain to GPP cpus (if supported)
	$SYSCTL "vm.pagedrain_cpumask=$GPP_CPUS_MASK"

	# Disable scheduler RT throttling 
	$SYSCTL "kernel.sched_rt_runtime_us=-1"

	# Disable softlockup detection.
	# Ideally this should be a cpumask 
	$SYSCTL "kernel.softlockup_thresh=-1"

	# Enable balancing in GPP.
	# We do it as the last step to avoid redundant domain 
	# rebuilds.
	echo 1 > gpp/cpuset.sched_load_balance
}

# Destory cpusets created for the system partitions
destroy_partitions()
{
	# Enable stopmachine (if supported)
	$SYSCTL "kernel.stopmachine_disabled=0"

	# Unrestrict pagedrain (if supported)
	$SYSCTL "vm.pagedrain_cpumask=$ALL_CPUS_MASK"

	# Enable scheduler RT throttling
	$SYSCTL "kernel.sched_rt_runtime_us=950000"

	# Enable softlockup detection
	$SYSCTL "kernel.softlockup_thresh=60"

	if [ -d gpp ]; then 
		# Move tasks to the root cpuset
		while read t; do
			echo $t > tasks 2>/dev/null
		done < gpp/tasks

		# Remove gpp
		rmdir gpp
	fi

	# Remove per cpu cpusets
	for i in $ISP_EACH_CPU; do
		[ -d cpu$i ] && rmdir cpu$i
	done

	# Enable systemwide balancing
	echo 1 > cpuset.sched_load_balance

	# Set default IRQ affinity
	echo $ALL_CPUS_MASK > /proc/irq/default_smp_affinity

	# Set affinity for all active IRQs
	for i in /proc/irq/[0-9]*; do
		echo $ALL_CPUS_MASK > $i/smp_affinity 2>/dev/null
	done
}

start()
{
 	echo -n $"Starting syspart: "

	# Partition the system
	create_partitions

	success $"syspart"
	echo 

	RETVAL=0
	return $RETVAL
}

stop()
{
 	echo -n $"Stopping syspart: "

	# Revert the partitioning
	destroy_partitions

	success $"syspart"
	echo

	RETVAL=0
	return $RETVAL 
}

case "$1" in
  start)
    start
    ;;

  stop)
    stop
    ;;

  status)
    ;;

  restart)
    stop
    start
    ;;

  condrestart)
    ;;

  *)
    echo $"Usage: $0 {start|stop|restart|condrestart|status}"
    exit 3
    ;;
esac

exit $RETVAL
